# Задание №7.1
# Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод
# __init__()), который должен принимать данные (список списков) для формирования матрицы.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в
# привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух
# объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой
# строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

class Matrix:
    def __init__(self, ls):
        self.ls = ls

    def __add__(self, other):
        for i in range(len(self.ls)):
            for j in range(len(self.ls[i])):
                self.ls[i][j] = self.ls[i][j] + other.ls[i][j]

        return Matrix(self.ls)

    def __str__(self):
        st = f'{self.ls[0]}\n--------------------\n{self.ls[1]}\n--------------------\n{self.ls[2]}'
        st = st.replace('[', ' | ')
        st = st.replace(']', ' | ')
        st = st.replace(',', ' | ')
        return st


matrix1 = Matrix([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
matrix2 = Matrix([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]])
print(f'Задание №7.1. {"*" * 100}')
print(matrix1 + matrix2)
print()

# Задание №7.2
# Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная
# сущность (класс) этого проекта — одежда, которая может иметь определенное название. К
# типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют
# параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и
# H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто
# (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке
# знания: реализовать абстрактные классы для основных классов проекта, проверить на
# практике работу декоратора @property.

from abc import ABC, abstractmethod

class Clothes(ABC):
    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def calc_consumption(self):
        pass

class Coat(Clothes):
    def __init__(self, size):
        self.__size = size

    @property # использую, чтобы иметь прямой доступ на чтение значения приватного атрибута за пределами классса
    def size(self):
        return self.__size

    @size.setter # использую, чтобы иметь прямой доступ для изменения значения приватного атрибута за пределами классса
    def size(self, size):
        self.__size = size

    @property # использую, чтобы данный метод можно было напрямую складывать с другим методом (их returns)
    def calc_consumption(self):
        return round(self.__size/6.5+0.5, 2)

class Suit(Clothes):
    def __init__(self, height):
        self.__height = height

    @property
    def height(self):
        return self.__height

    @height.setter
    def height(self, height):
        self.__height = height

    @property
    def calc_consumption(self):
        return round(2 * self.__height + 0.3, 2)


coat = Coat(48)
suit = Suit(176)

print(f'Задание №7.2. {"*" * 100}')
print(f'На изготовление одного пальто размера "{coat.size}" расход ткани составляет: {coat.calc_consumption}')
print(f'На изготовление одного костюма для роста "{suit.height}" расход ткани составляет: {suit.calc_consumption}')
print(f'Общий расход ткани составляет: {coat.calc_consumption + suit.calc_consumption}') # чтобы сложить два метода необходимо для этих методов определить декоратор "@property"

coat.size = 50
print(f'На изготовление одного пальто размера "{coat.size}" расход ткани составляет: {coat.calc_consumption}')
suit.height = 180
print(f'На изготовление одного костюма для роста "{suit.height}" расход ткани составляет: {suit.calc_consumption}')
print(f'Общий расход ткани составляет: {coat.calc_consumption + suit.calc_consumption}')
print()

# Задание 7.3
# Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо
# создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий
# количеству ячеек клетки (целое число). В классе должны быть реализованы методы
# © geekbrains.ru 20
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только
# к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением
# до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
# сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний
# ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n*****.


class Cell:
    def __init__(self, cells):
        self.__cells = cells

    @property
    def cells(self):
        return self.__cells

    @cells.setter
    def cells(self, cells):
        self.__cells = cells

    def __add__(self, other):
        return self.__cells + other.__cells

    def __sub__(self, other):
        if self.__cells - other.__cells < 0:
            return 'Недостаточно ячеек для вычитания'
        else:
            return self.__cells - other.__cells

    def __mul__(self, other):
        return self.__cells * other.__cells

    def __truediv__(self, other):
        return self.__cells / other.__cells

    def make_order(self, num):
        ls = ''
        total = self.__cells
        while num <= total:
            ls = ls + (f'{"*" * num}\\n')
            total -= num
        ls = ls + (f'{"*" * total}')
        return ls

cell1 = Cell(2)
cell2 = Cell(3)

print(f'Задание №7.3. {"*" * 100}')
print(f'В результате объединения клеток с количеством ячеек {cell1.cells} и {cell2.cells} образовалась клетка с количеством ячеек {cell1 + cell2}')
print(cell1 - cell2)
cell1.cells = 7
print(f'В результате вычитания клетки с количеством ячеек {cell2.cells} из клетки с количеством ячеек {cell1.cells} в клетке осталось {cell1 - cell2} ячеек')
print(f'В результате произведения клеток с количеством ячеек {cell1.cells} и {cell2.cells} образовалась клетка с количеством ячеек: {cell1 * cell2}')
print(f'В результате целочисленнго деления клеток с ячейками {cell1.cells} и {cell2.cells} образовалась клетка с количеством ячеек: {round(cell1 / cell2)}')
cell2.cells = 17
print()
print(f'Расположение ячеек клетки с количеством {cell2.cells} ячеек в рядах по 5 ячеек:\n {cell2.make_order(5)}')




